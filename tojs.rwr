% parameter namedLetExpr
% rewrite tojs {
  Program [TopLevelSexpr+] = ‛«TopLevelSexpr»’
  
  TopLevelSexpr_functionDefinition [lp _define lp2 name formals* rp2 Body rp] = ‛
function «name» («formals») {\nlet RESULT = undefined;«Body»
return RESULT;
}’

  TopLevelSexpr_functionEquivalence [lp _define name name2 rp] = ‛\nlet «name» = «name2»;’
  TopLevelSexpr_global [lp _define name BodyItem rp] = ‛\nlet «name» = «BodyItem»;’
  TopLevelSexpr_call [f] = ‛\n«f»;’
  TopLevelSexpr_other [Sexpr] = ‛«Sexpr»’
  Sexpr [x] = ‛«x»’
  Formal [sym] = ‛«sym», ’

  Body [BodyItem Body?] = ‛\n«BodyItem»;«Body»’

  BodyItem_cond [lp _cond CondClause+ ElseClause? rp] = ‛if (false) {\n}«CondClause»«ElseClause»’
  BodyItem_ifThenElse [lp _if Guard ThenExpr ElseExpr rp] = ‛if («Guard») {\n«ThenExpr»\n}\nelse {\n«ElseExpr»}’
  BodyItem_ifThen [lp _if Guard ThenExpr rp] = ‛if («Guard») {\n«ThenExpr»\n}’
  BodyItem_and [lp _and AndBody rp] = ‛RESULT = «AndBody»’

  BodyItem_letLoop [lp _let symbol NamedLetParameter Body rp] = 
    ‛function loop (⎨firstPart ‛«NamedLetParameter»’⎬) {\nlet RESULT = undefined;«Body»\nreturn RESULT;\n}\nRESULT = loop (⎨secondPart ‛«NamedLetParameter»’⎬)’

  BodyItem_letAsterisk [lp _let Bindings Body rp] = ‛«Bindings»«Body»’
  BodyItem_let [lp _let Bindings Body rp] = ‛«Bindings»«Body»’
  BodyItem_atom [a] =‛RESULT = «a»’
  BodyItem_call [f] =‛RESULT = «f»’
  BodyItem_listConstant [k] =‛RESULT = «k»’

  AndBody_compound [item more] = ‛«item» && «more»’
  AndBody_single [item] = ‛(«item»)’
  AndBodyItem [i] = ‛«i»’
  FunctionCall_plus [lp _plus Arg1 Arg2 rp] = ‛(RESULT = «Arg1» + «Arg2»)’
  FunctionCall_loop [lp _loop Arg* rp] = ‛«Arg»\nNEXT = RESULT’
  FunctionCall_other [lp symbol Arg* rp] = ‛(RESULT = «symbol» («Arg»))’
  CondClause [lp Guard Body rp] = ‛\nelse if («Guard») {\n«Body»\n}’
  ElseClause [lp _else Body rp] = ‛\nelse {\n«Body»\n}’
  ThenExpr [i] = ‛«i»’
  ElseExpr [i] = ‛«i»’

  Guard [e] = ‛«e»’  
  Expr_and [lp _and AndBody rp] = ‛«AndBody»’
  Expr_atom [a] = ‛(RESULT = «a»)’
  Expr_call [f] = ‛(RESULT = «f»)’

  Bindings [lp Binding+ rp] = ‛«Binding»’
  Binding [lp symbol BodyItem rp] = ‛\nlet «symbol» = «BodyItem»;’
  NamedLetBindings [lp lp2 v e rp2 rp] = ‛«v»~«e»’

  Arg_atom [a] = ‛«a», ’   
  Arg_call [f] = ‛«f», ’   

  atom_nil [lp rp] = ‛null’
  atom_integerConstant [lb i rb] = ‛«i»’
  atom_stringConstant [lb s rb] = ‛«s»’
  atom_symbolConstant [lb symbol rb] = ‛"«symbol»"’
  atom_listConstant [k] = ‛«k»’
  atom_variable [s] = ‛«s»’

  integer [d+] = ‛«d»’
  string [lq cs* rq] = ‛«lq»«cs»«rq»’
  symbol [id _dot* id2*] = ‛«id»«_dot»«id2»’
  id_try [x] = ‛ftry’
  id_var [x] = ‛vvar’
  id_not [x] = ‛!’
  id_other [c cs*] = ‛«c»«cs»’
  firstLetter [c] = ‛«c»’
  followLetter [c] = ‛«c»’
  jsletter_asterisk [c] = ‛_A’
  jsletter_bang [c] = ‛_B’
  jsletter_questionMark [c] = ‛_Q’
  jsletter_dash [c] = ‛__’
  jsletter_other [c] = ‛«c»’
  special [c] = ‛«c»’
  separator [c] = ‛«c»’

  List_listConstant [k] = ‛«k»’
  List_dotted [lp es+ _dot e rp] = ‛[«es», «e»]’
  List_listMultiple [lp e es+ rp] = ‛\n[«e»«es»]’
  List_listOfOne [lp e rp] = ‛\n[«e»]’

  ListConstant_nil [lb rb] = ‛nil’
  ListConstant_dotted [lb es+ _dot e rb] = ‛[«es», «e»]’
  ListConstant_multiple [lb e es* rb] = ‛\n[«e», «es»]’

  SpaceSexpr [e] = ‛«e», ’

  comment [_semi cs* nl] = ‛«_semi»«cs»«nl»’
  space [s] = ‛«s»’
}
