tojs {
  Program = TopLevelSexpr+
  TopLevelSexpr =
    | "(" "define" "(" symbol Formal* ")" Body ")" -- functionDefinition
    | "(" "define" symbol symbol ")" -- functionEquivalence
    | "(" "define" symbol BodyItem<Body> ")" -- global
    | FunctionCall -- call
    | Sexpr                         -- other
  Sexpr = List | atom
  Formal = symbol

  Body = BodyItem<Body> Body?
  
  BodyItem<Bod>=
    | "(" "cond" CondClause+ ElseClause? ")" -- cond
    | "(" "if" Guard ThenExpr ElseExpr ")" -- ifThenElse
    | "(" "if" Guard ThenExpr ")" -- ifThen
    | "(" "and" AndBody ")" -- and
    | "(" "let*" Bindings Bod ")" -- letAsterisk
    | "(" "let" symbol Bindings Bod ")" -- letLoop
    | "(" "let" Bindings Bod ")" -- let
    | atom -- atom
    | FunctionCall -- call
    | ListConstant -- listConstant

  AndBody =
    | BodyItem<AndBody> AndBody -- compound
    | BodyItem<AndBody> -- single
  AndBodyItem<Bod> = BodyItem<Bod>  

  FunctionCall = 
    | "(" "+" atom atom ")" -- plus
    | "(" symbol Arg* ")" -- other
  CondClause = "(" Guard Body ")"
  ElseClause = "(" "else" Body ")"
  ThenExpr = BodyItem<Body>
  ElseExpr = BodyItem<Body>
  
  Guard = Expr
  Expr =
    | "(" "and" Body ")" -- and
    | atom -- atom
    | FunctionCall -- call

  Bindings = "(" Binding+ ")"
  Binding = "(" symbol BodyItem<Body> ")"
  
  Arg =
    | atom -- atom
    | FunctionCall -- call

  atom =
    | "(" ")" -- nil
    | "‹" integer "›" -- integerConstant
    | "‹" string "›" -- stringConstant
    | "‹" symbol "›" -- symbolConstant
    | applySyntactic<ListConstant> -- listConstant
    | symbol -- variable

  integer = digit+
  string = "\"" (~"\"" any)* "\""
  symbol = id ("." id)*
  id =
    | "try" -- try
    | "not" -- not
    | firstLetter followLetter* -- other
  firstLetter = jsletter | (~separator ~unprintable any)
  followLetter = jsletter | digit | (~separator ~unprintable any)
  jsletter =
    | "*" -- asterisk
    | "!" -- bang
    | "?" -- questionMark
    | letter -- other
  special  = ";" | "#" | "(" | ")" | "‹" | "›" | "." | "⎨" | "⎬"
  unprintable = ("\x00" .. "\x20") | "\x7F"
  separator = space | special | end

  List =
    | ListConstant -- listConstant
    | "(" Sexpr+ "." Sexpr ")" -- dotted
    | "(" Sexpr SpaceSexpr+ ")" -- listMultiple
    | "(" Sexpr ")" -- listOfOne

  ListConstant = 
    | "⎨" Sexpr+ "." Sexpr "⎬"  -- dotted
    | "⎨" Sexpr SpaceSexpr* "⎬" -- multiple
    | "⎨" "⎬"  -- nil

  SpaceSexpr = Sexpr

  comment = ";" (~"\n" any)* "\n"
  space += comment
}

//+ (define (L_c x) (cadr (cddddr x)))
//+ (define var ‹?›)
//+ (define name cadr)
//+ (define goals ⎨⎨‹path› ‹a› ‹f› ⎨‹?› ‹P›⎬⎬⎬)
//+ (define db ⎨⎨⎨‹edge› ‹a› ‹b›⎬⎬ ⎨⎨‹edge› ‹a› ‹f›⎬⎬ ⎨⎨‹edge› ‹a› ‹g›⎬⎬ ⎨⎨‹edge› ‹b› ‹c›⎬⎬ ⎨⎨‹edge› ‹b› ‹d›⎬⎬ ⎨⎨‹edge› ‹c› ‹d›⎬⎬ ⎨⎨‹edge› ‹c› ‹e›⎬⎬ ⎨⎨‹edge› ‹g› ‹h›⎬⎬ ⎨⎨‹edge› ‹d› ‹h›⎬⎬ ⎨⎨‹edge› ‹h› ‹e›⎬⎬ ⎨⎨‹edge› ‹h› ‹f›⎬⎬ ⎨⎨‹path› ⎨‹?› ‹A›⎬ ⎨‹?› ‹B›⎬ ⎨⎨‹?› ‹A›⎬ ⎨‹?› ‹B›⎬⎬⎬ ⎨‹edge› ⎨‹?› ‹A›⎬ ⎨‹?› ‹B›⎬⎬⎬ ⎨⎨‹path› ⎨‹?› ‹A›⎬ ⎨‹?› ‹B›⎬ ⎨⎨‹?› ‹A›⎬ . ⎨‹?› ‹CB›⎬⎬⎬ ⎨‹edge› ⎨‹?› ‹A›⎬ ⎨‹?› ‹C›⎬⎬ ⎨‹path› ⎨‹?› ‹C›⎬ ⎨‹?› ‹B›⎬ ⎨‹?› ‹CB›⎬⎬⎬⎬)
//+ (define sdb ⎨⎨⎨⎨‹path› ⎨‹?› ‹A›⎬ ⎨‹?› ‹B›⎬ ⎨⎨‹?› ‹A›⎬ . ⎨‹?› ‹CB›⎬⎬⎬ ⎨‹edge› ⎨‹?› ‹A›⎬ ⎨‹?› ‹C›⎬⎬ ⎨‹path› ⎨‹?› ‹C›⎬ ⎨‹?› ‹B›⎬ ⎨‹?› ‹CB›⎬⎬⎬⎬)
//+ (define (prove3 g e n)  (cond ((null? g)          (print-frame e))        (else          (try g db e n))))
//+ (define (var? x)  xs  (and (pair? x)       (eq? var (car x))))
//+ (define (print-frame e)  (newline)  (let loop ((ee e))    (cond ((pair? (cdr ee))            (cond ((null? (time (caar ee)))                    (display (cadaar ee))                    (display " = ")                    (display (resolve (caar ee) e))                    (newline)))       (loop (cdr ee))))))