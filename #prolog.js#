class Pair {
    constructor (first, rest = null) {
        this.first = first;
        this.rest = rest;
    }
    
    toArray () {
        const result = [];
        let current = this;
        while (current !== null) {
            if (current.first instanceof Pair) {
                result.push(current.first.toArray());  // Recursive call!
            } else {
                result.push(current.first);
            }
            current = current.rest;
        }
        return result;
    }
    
    // Get length
    get length() {
        let count = 0;
        let current = this;
        while (current !== null) {
            count++;
            current = current.rest;
        }
        return count;
    }
    
    // toString for easier debugging - handles nested Pairs recursively
    toString() {
        const elements = [];
        let current = this;
        
        while (current !== null) {
            if (current.first instanceof Pair) {
                elements.push(current.first.toString());
            } else {
                elements.push(current.first);
            }
            current = current.rest;
        }
        
        return `(${elements.join(' ')})`;
    }
}

function car (pair) {
    return pair ? pair.first : null;
}

function cdr (pair) {
    return pair ? pair.rest : null;
}

function cons (x, y) {
    return new Pair(x, y);
}

function listify(arg) {
    // 1. If not an array, return as is
    if (!Array.isArray(arg)) {
        return arg;
    }
    
    // 3. If empty array, return null
    if (arg.length === 0) {
        return null;
    }
    
    // 2. If array, return list of listified elements
    let result = null;
    for (let i = arg.length - 1; i >= 0; i--) {
        result = cons(listify(arg[i]), result);  // Recursive call!
    }
    
    return result;
}

function list (...args) {
    return listify (args);
}
    
// Convert Pair list to JS array (already exists as toArray method)
function listToArray(list) {
    return list ? list.toArray() : [];
}

// Additional utility functions

// Check if something is a Pair (could be improper list)
function isPair(obj) {
    return obj instanceof Pair;
}

// List operations
function append(list1, list2) {
    if (list1 === null) return list2;
    return cons(car(list1), append(cdr(list1), list2));
}

function reverse(list) {
    let result = null;
    let current = list;
    while (current !== null) {
        result = cons(car(current), result);
        current = cdr(current);
    }
    return result;
}


// Mapcar - applies function to each ELEMENT, returns list of results
function mapcar(fn, list) {
    if (list === null) return null;
    return cons(fn(car(list)), mapcar(fn, cdr(list)));
}

// Maplist - applies function to each SUBLIST (list and its successive tails)
function maplist(fn, list) {
    if (list === null) return null;
    return cons(fn(list), maplist(fn, cdr(list)));
}

// Filter function over list
function filterList(predicate, list) {
    if (list === null) return null;
    
    const head = car(list);
    const tail = filterList(predicate, cdr(list));
    
    if (predicate(head)) {
        return cons(head, tail);
    } else {
        return tail;
    }
}

function caar (list) {
    return car (car (list));
}
function cadr (list) {
    return car (cdr (list));
}
function caddr (list) {
    return car (cdr (cdr (list)));
}
function cadddr (list) {
    return car (cdr (cdr (cdr (list))));
}
function cddr (list) {
    return cdr (cdr (list));
}
function cdddr (list) {
    return cdr (cdr (cdr (list)));
}
function cddddr (list) {
    return cdr (cdr (cdr (cdr (list))));
}

function null_Q (list) {
    return list == [] || list == null;
}

function pair_Q (list) {
    return isPair (list);
}

function eq_Q (x, y) {
    return x === y;
}
function eqv_Q (x, y) {
    return Object.is (x, y);
}

function newline () {
    console.log ("");
}

function display (x) {
    if (x == null) {
	console.log ("nil");
    } else { 
	console.log (x.toString ());
    }
}
function ftry (db, g, r, e, n) {
let RESULT = undefined;
RESULT = (RESULT = display (g));
if ((RESULT = (RESULT = null_Q (r)))) {
RESULT = "false"
}
else {

let a = RESULT = (RESULT = copy ((RESULT = car (r)), (RESULT = list (n))));
let ne = RESULT = (RESULT = unify ((RESULT = car (g)), (RESULT = car (a)), e));
if ((RESULT = ne)) {
RESULT = (RESULT = prove3 (db, (RESULT = append ((RESULT = cdr (a)), (RESULT = cdr (g)))), ne, (RESULT = 1 + n)))
};
RESULT = (RESULT = ftry (db, g, (RESULT = cdr (r)), e, n));};
return RESULT;
}
function prove3 (db, g, e, n) {
let RESULT = undefined;
RESULT = (RESULT = display (g));
if (false) {
}
else if ((RESULT = (RESULT = null_Q (g)))) {

RESULT = (RESULT = print__frame (e));
}
else {

RESULT = (RESULT = ftry (db, g, db, e, n));
};
return RESULT;
}
let link = list;
let L_l = car;
let L_g = cadr;
let L_r = caddr;
let L_e = cadddr;
function L_n (x) {
let RESULT = undefined;
RESULT = (RESULT = car ((RESULT = cddddr (x))));
return RESULT;
}
function back5 (db, l, g, r, e, n) {
let RESULT = undefined;
if (RESULT = (RESULT = pair_Q (g)) && (RESULT = (RESULT = pair_Q (r)))) {
RESULT = (RESULT = prove5 (db, l, g, (RESULT = cdr (r)), e, n))
}
else {
RESULT = (RESULT = prove5 (db, (RESULT = L_l (l)), (RESULT = L_g (l)), (RESULT = cdr ((RESULT = L_r (l)))), (RESULT = L_e (l)), (RESULT = L_n (l))))};
return RESULT;
}
function prove5 (db, l, g, r, e, n) {
let RESULT = undefined;
if (false) {
}
else if ((RESULT = (RESULT = null_Q (g)))) {

RESULT = (RESULT = print__frame (e));
RESULT = (RESULT = back5 (db, l, g, r, e, n));
}
else if ((RESULT = (RESULT = null_Q (r)))) {

if ((RESULT = (RESULT = null_Q (l)))) {
RESULT = "true"
}
else {
RESULT = (RESULT = back5 (db, l, g, r, e, n))};
}
else {


let a = RESULT = (RESULT = copy ((RESULT = car (r)), n));
let e_A = RESULT = (RESULT = unify ((RESULT = car (a)), (RESULT = car (g)), e));
if ((RESULT = e_A)) {
RESULT = (RESULT = prove5 (db, (RESULT = link (l, g, r, e, n)), (RESULT = append ((RESULT = cdr (a)), (RESULT = cdr (g)))), db, e_A, (RESULT = 1 + n)))
}
else {
RESULT = (RESULT = back5 (db, l, g, r, e, n))};;
};
return RESULT;
}
function L_c (x) {
let RESULT = undefined;
RESULT = (RESULT = cadr ((RESULT = cddddr (x))));
return RESULT;
}
function clear_r (x) {
let RESULT = undefined;
RESULT = (RESULT = set__car_B ((RESULT = cddr (x)), 
[null, ]));
return RESULT;
}
function back6 (db, l, g, r, e, n, c) {
let RESULT = undefined;
if (false) {
}
else if (RESULT = (RESULT = pair_Q (g)) && (RESULT = (RESULT = pair_Q (r)))) {

RESULT = (RESULT = prove6 (db, l, g, (RESULT = cdr (r)), e, n, c));
}
else if ((RESULT = (RESULT = pair_Q (l)))) {

RESULT = (RESULT = prove6 (db, (RESULT = L_l (l)), (RESULT = L_g (l)), (RESULT = cdr ((RESULT = L_r (l)))), (RESULT = L_e (l)), (RESULT = L_n (l)), (RESULT = L_c (l))));
};
return RESULT;
}
function prove6 (db, l, g, r, e, n, c) {
let RESULT = undefined;
if (false) {
}
else if ((RESULT = (RESULT = null_Q (g)))) {

RESULT = (RESULT = print__frame (e));
RESULT = (RESULT = back6 (db, l, g, r, e, n, c));
}
else if ((RESULT = (RESULT = eq_Q ("_B", (RESULT = car (g)))))) {

RESULT = (RESULT = clear_r (c));
RESULT = (RESULT = prove6 (db, c, (RESULT = cdr (g)), r, e, n, c));
}
else if ((RESULT = (RESULT = eq_Q ("r_B", (RESULT = car (g)))))) {

RESULT = (RESULT = prove6 (db, l, (RESULT = cddr (g)), r, e, n, (RESULT = cadr (g))));
}
else if ((RESULT = (RESULT = null_Q (r)))) {

if ((RESULT = (RESULT = null_Q (l)))) {
RESULT = "true"
}
else {
RESULT = (RESULT = back6 (db, l, g, r, e, n, c))};
}
else {


let a = RESULT = (RESULT = copy ((RESULT = car (r)), n));
let e_A = RESULT = (RESULT = unify ((RESULT = car (a)), (RESULT = car (g)), e));
if ((RESULT = e_A)) {
RESULT = (RESULT = prove6 (db, (RESULT = link (l, g, r, e, n, c)), (RESULT = append ((RESULT = cdr (a)), (RESULT = list ("r_B", "l")), (RESULT = cdr (g)))), db, e_A, (RESULT = 1 + n), l))
}
else {
RESULT = (RESULT = back6 (db, l, g, r, e, n, c))};;
};
return RESULT;
}
let empty = listify (RESULT = 
[
["bottom", ], ]);
let vvar = listify (RESULT = "_Q");
let name = cadr;
let time = cddr;
function var_Q (x) {
let RESULT = undefined;
RESULT = RESULT = (RESULT = pair_Q (x)) && (RESULT = (RESULT = eq_Q (vvar, (RESULT = car (x)))));
return RESULT;
}
function lookup (v, e) {
let RESULT = undefined;

let id = RESULT = (RESULT = name (v));
let t = RESULT = (RESULT = time (v));
function loop (e) {
let RESULT = undefined;
if (false) {
}
else if ((RESULT = (RESULT = ! ((RESULT = pair_Q ((RESULT = caar (e)))))))) {

RESULT = "false";
}
else if (RESULT = (RESULT = eq_Q (id, (RESULT = name ((RESULT = caar (e)))))) && (RESULT = (RESULT = eqv_Q (t, (RESULT = time ((RESULT = caar (e)))))))) {

RESULT = (RESULT = car (e));
}
else {

RESULT = (RESULT = cdr (e)), 
NEXT = RESULT;
};
return RESULT;
}
RESULT = loop (RESULT = e);;
return RESULT;
}
function value (x, e) {
let RESULT = undefined;
if ((RESULT = (RESULT = var_Q (x)))) {

let v = RESULT = (RESULT = lookup (x, e));
if ((RESULT = v)) {
RESULT = (RESULT = value ((RESULT = cadr (v)), e))
}
else {
RESULT = x};
}
else {
RESULT = x};
return RESULT;
}
function copy (x, n) {
let RESULT = undefined;
if (false) {
}
else if ((RESULT = (RESULT = ! ((RESULT = pair_Q (x)))))) {

RESULT = x;
}
else if ((RESULT = (RESULT = var_Q (x)))) {

RESULT = (RESULT = append (x, n));
}
else {

RESULT = (RESULT = cons ((RESULT = copy ((RESULT = car (x)), n)), (RESULT = copy ((RESULT = cdr (x)), n))));
};
return RESULT;
}
function bind (x, y, e) {
let RESULT = undefined;
RESULT = (RESULT = cons ((RESULT = list (x, y)), e));
return RESULT;
}
function unify (xx, yy, e) {
    let RESULT = undefined;
    
    let x = RESULT = (RESULT = value (xx, e));
    let y = RESULT = (RESULT = value (yy, e));
    if (false) {
    }
    else if ((RESULT = (RESULT = eq_Q (x, y)))) {
	
	RESULT = e;
    }
    else if ((RESULT = (RESULT = var_Q (x)))) {
	
	RESULT = (RESULT = bind (x, y, e));
    }
    else if ((RESULT = (RESULT = var_Q (y)))) {
	
	RESULT = (RESULT = bind (y, x, e));
    }
    else if (RESULT = (RESULT = ! ((RESULT = pair_Q (x)))) || (RESULT = (RESULT = ! ((RESULT = pair_Q (y)))))) {
	
	RESULT = "false";
    }
    else {
	
	
	let e_A = RESULT = (RESULT = unify ((RESULT = car (x)), (RESULT = car (y)), e));
	RESULT = RESULT = e_A && (RESULT = (RESULT = unify ((RESULT = cdr (x)), (RESULT = cdr (y)), e_A)));;
    };;
    return RESULT;
}

function resolve (x, e) {
let RESULT = undefined;
if (false) {
}
else if ((RESULT = (RESULT = ! ((RESULT = pair_Q (x)))))) {

RESULT = x;
}
else if ((RESULT = (RESULT = var_Q (x)))) {


let v = RESULT = (RESULT = value (x, e));
if ((RESULT = (RESULT = var_Q (v)))) {
RESULT = v
}
else {
RESULT = (RESULT = resolve (v, e))};;
}
else {

RESULT = (RESULT = cons ((RESULT = resolve ((RESULT = car (x)), e)), (RESULT = resolve ((RESULT = cdr (x)), e))));
};
return RESULT;
}
function print__frame (e) {
let RESULT = undefined;
RESULT = (RESULT = newline ());
function loop (ee) {
let RESULT = undefined;
if (false) {
}
else if ((RESULT = (RESULT = pair_Q ((RESULT = cdr (ee)))))) {

if (false) {
}
else if ((RESULT = (RESULT = null_Q ((RESULT = time ((RESULT = caar (ee)))))))) {

RESULT = (RESULT = display ((RESULT = cadaar (ee))));
RESULT = (RESULT = display (" = "));
RESULT = (RESULT = display ((RESULT = resolve ((RESULT = caar (ee)), e))));
RESULT = (RESULT = newline ());
};
RESULT = (RESULT = cdr (ee)), 
NEXT = RESULT;
};
return RESULT;
}
RESULT = loop (RESULT = e);
return RESULT;
}
let db0 = listify (RESULT = 
[
[
["edge", "a", "b", ], ], 
[
["path", 
["_Q", "A", ], 
["_Q", "B", ], 
[
["_Q", "A", ], 
["_Q", "B", ], ], ], 
["edge", 
["_Q", "A", ], 
["_Q", "B", ], ], ], ]);
let goals0 = listify (RESULT = 
[
["path", "a", "b", 
["_Q", "P", ], ], ]);
(RESULT = display ((RESULT = unify ("a", "a", empty))));
(RESULT = newline ());
(RESULT = display ("testA"));
(RESULT = newline ());
(RESULT = display ((RESULT = unify ("a", 
["_Q", "X", ], empty))));
